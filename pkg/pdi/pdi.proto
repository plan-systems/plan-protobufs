// See http://github.com/plan-systems/plan-protobufs/

syntax = "proto3";

package pdi;

import "plan/plan.proto";
import "ski/ski.proto";





/**********************************************************************************************************************
StorageProvider is the gRPC service interface for a community's append-only shared persistent data store.

In addition to being a repository of community member txns/extrinsics, a StorageProvider (or set of
StorageProviders), essentially serve as the community's validators, meaning they:
    (a) authenticate that a txn is officially part of the community record, and 
    (b) seal *when* a txn became part of the record
    
Although the StorageProvider abstraction is modeled after a blockchain (an append-only db),
its implementation can either be centralized *or* decentralized.  This means a StorageProvider
implementation could be a blockchain or a conventional centralized server/cluster.

In the StorageProvider model (as with a conventional blockchain model), trust is externalized
to outside the system by use of StorageProvider-maintained units of account: 
    (1) Kb - Number of kilobytes of txn data a given address (account) can post.
    (2) Op - Number of "operations" a given address can perform.  Posting a new txn costs 1 Op.
These units of account are solely a mechanism for controlling who has append access to the community's store and is
generally managed via the standard procedures for admitting new members.

Newcomers may be correctly point out that a blockchain/DLT model is a poor choice to model generalized storage.
However, it's not the only storage abstraction in PLAN.  Allow us to introduce the Cloud File Interface:
    https://github.com/plan-systems/design-docs/blob/master/PLAN-API-Documentation.md#Cloud-File-Interface

And for more about StorageProvider:
    https://github.com/plan-systems/design-docs/blob/master/PLAN-API-Documentation.md#Persistent-Data-Interface
**********************************************************************************************************************/
service StorageProvider {

    // Starts a new client session.
    rpc         StartSession(SessionReq)                        returns (StorageInfo);

    // Requests a sequence of txn IDs within a specified time window and other query criteria.
    rpc         Scan(TxnScan)                                   returns (stream TxnList);

    // Requests a set of txns to be sent to the client.
    rpc         FetchTxns(TxnList)                              returns (stream RawTxn);

    // Submits a txn ready to be written to the StorageProvider's permanent txn store/ledger.
    // RawTxn is generated by this StorageProvider's corresponding TxnEncoder.
    // For each StorageProvider implementation, one uses the accompanying txn marshalling encoder
    //    and decoder (TxnEncoder and TxnDecoder).
    rpc         CommitTxn(RawTxn)                               returns (plan.Status);


    // TODO: SPs can offer peer discovery services

}



message SessionReq {

    // The requested storage epoch to be accessed.
                StorageEpoch        storage_epoch               = 1;

    // An empty but signed txn that demonstrates to the host StorageProvider that the client
    //    has an active account with this storage provider.
                RawTxn              proof_of_access             = 2;     

}




message StorageInfo {

    // This is a sig of SessionReq.ProofOfAccess, signed with the latest StorageProvider key.
    // This authenticates this StorageProvider (since a 3rd party attempting to impersonate a StorageProvider
    //    node would be unable to produce this signature).   
                bytes               sig_response               = 1;     


}



// TxnInfo contains information derivable from EACH native/raw txn.
// It's used during txn processing or _about_ a Txn being processed.
// Although a TxnEncoder internally encodes a payload segment into a Txn to be signed, 
//     that can only happen after the agent has segmented the payload 
//     buffer into sizes appropriate for storage medium. 
// For example, the Ethereum agent must break the payload into 31k pieces so that the byte size of 
//     Txn.TxnData is strictly less than 32k (Ethereum's txn size limit).
message TxnInfo {

    /*****************************************************
    ** StorageProvider Use
    **/

    // Transfer(s) (optional)
    repeated    Transfer            transfers                   = 2;

    /*****************************************************
    ** Contents Info
    **/

    // Describes how to to decode the payload data (this value is identical for each segment that comprises a reassembled payload)
    // This specifies the encoding of the payload and conforms to https://github.com/plan-systems/multicodec
    // In PLAN, this value is typically plan.EntryCryptCodecID.
                uint32              payload_codec               = 5;

    // Segment byte size
                uint32              seg_sz                      = 8;

    // When a client payload is large, it must be split into multiple native txns.
    // This info specifies which segment this is and how many total segments there are.
    // Note: SegmentIndex uses zero-based indexing 
                uint32              seg_index                   = 9;
                uint32              seg_total                   = 10;

    // Txn URID of the segment preceding this one (or nil if this is the first segment)
    // This allows an entire segment chain to be implicitly specified via the URID of the last segment.
                bytes               prevURID                    = 11;

    // Unix timestamp of when this txn was encoded and signed for storage.
                int64               time_sealed                 = 12;


    /*****************************************************
    ** Regenerated Info (nil when encoding)
    **/

    // Address/pubkey that signed this txn
                bytes               from                        = 20;

    // Binary URID of this txn, derived from time_sealed and txn_hashname.
                bytes               URID                        = 21;

}


message Transfer {

    // Pubkey/address of the recipient
                bytes               to                          = 1;

    // Kb is the storage unit of account on a StorageProvider.
    // Each txn "costs" Kb for each kb size of the txn.
                int64               kb                          = 2;

    // Ops refers to the energy and processing cost for operations requested of a StorageProvider (typically a txn commit)
    // Each txn committed "costs" 1 op for example.
                int64               ops                         = 3;
}



// RawTxn reflects a txn native to/from a community's StorageProvider network.
message RawTxn {

    // Always generate (or confirm) locally for security (set to nil for transport)
                bytes               URID                        = 1;

    // Info about the status this txn.  
    // Set to nil if n/a or if txn is not yet committed.
                TxnMetaInfo         txn_meta_info               = 2;

    // Raw native txn data and conforms to all native txn requirements (e.g. native max size).
                bytes               bytes                       = 3;

}


// TxnMetaInfo is information *about* the status of a transaction 
message TxnMetaInfo {

    // Txn ID
                bytes               URID                        = 1;

   // Status information about the associated txn
                TxnStatus           txn_status                  = 2;

    // Contains additional alert or status information
                plan.Status         alert                       = 3;

    // Consensus-based unix timestamp for this txn (or 0 if not available).  
    // If txn_status == FINALIZED, then this timestamp:
    //      - won't ever change, 
    //      - is universal across StorageProvider peers
    //      - is as trustworthy as the StorageProvider network.
                int64               consensus_time              = 4;

    // Proof that this txn was indeed received and validated by a valid StorageProvider.
                bytes               txn_validation              = 5;
}






message TxnScan {

    // Specifies the bounding timestamps (TxnInfo.TimeSealed) of txns to consider (inclusive).
    // These values are standard unix timestamps (seconds elapsed since 00:00 Jan 1, 1970).
                int64               timestamp_start             = 1;
                int64               timestamp_stop              = 2;
  
    // If set, this query will remain active/open even after there are no more entries to return.
    // All txn status changes or updates will be reported, regardless of timestamp.
    // This is a how client is notified about newly committed txns and status changes in previously committed txns.
                bool                send_txn_updates            = 5;    

    // If > 0, this limits the the number of txn URIDs returned until the request is considered complete.
                int32               max_txns                    = 7;

}

message TxnList {

    // Batch of txn URIDs (binary form)
    // Entries that are zero-length should be considered valid "no-ops".
    repeated    bytes               URIDs                       = 2;

    // len(statuses) == len(URIDs): the ith byte of is the TxnStatus of URIDs[i].
    // Note: this field is ignored for SendTxns() 
                bytes               statuses                    = 3;
}


message StorageAccount {

    // Kilobytes able to be used for txns
                int64               kb_balance                  = 1;

    // Number of "operations" able to be posted to a StorageProvider network.
                int64               op_balance                  = 2;

    // Set if this account is permitted to transfer to other accounts.
                bool                can_transfer                = 3;

}




// TxnStatus describes the status of a txn on a StorageProvider.
// Note: odd values reflect an error state
enum TxnStatus {

    // The txn is yet to be committed to storage
    NEW                         = 0;

    // The txn is in the process of being committed
    COMMITTING                  = 2;

    // This txn does not exist, is lost, or is otherwise not available 
    MISSING                     = 5;

    // This txn has failed to commit because of a server-side error, failure, or shutdown
    COMMIT_FAILED               = 7;    
    
    // The txn has been committed and has been confirmed as stored (but could still potentially be reverted)
    COMMITTED                   = 8;

    // The txn was confirmed COMMITTED earlier in time, but has since been revoked (and can be treated as MISSING)
    REVOKED                     = 9;

    // The txn has been committed, confirmed as stored, and faces no possibility of being reverted/revoked.
    FINALIZED                   = 16;

}







/**********************************************************************************************************************
A channel's access control channel effectively specifies an privilege access level for all member IDs in the community. 

A channel designated as an access control channel can be used for any number of channels, 
effectively allowing channels used to control access more multiple channels.  This "comes for free" since
access control channels don't contain any references to channels that use them to control access. */

enum AccessLevel {

    // Not used
    NO_ACCESS                   = 0;

    // Has crypto to decrypt entries from the given channel
    READ_ACCESS                 = 1;

    // Permitted to author: POST_NEW_CONTENT, REMOVE_ENTRIES (for self), SUPERSEDE_ENTRY (for self) 
    READWRITE_ACCESS            = 2;

    // Permitted to author: POST_NEW_CONTENT, REMOVE_ENTRIES (for all), SUPERSEDE_ENTRY (for self), EDIT_CHANNEL_INFO, EDIT_ACCESS_GRANTS
    MODERATOR_ACCESS            = 3;

    // Same as MODERATOR_ACCESS plus can grant others MODERATOR_ACCESS and can issue EDIT_ACCESS_GRANTS
    SUPER_MODERATOR_ACCESS      = 4;

    // Same as SUPER_MODERATOR_ACCESS plus can grant others SUPER_MODERATOR_ACCESS and can author entry type NEW_CHANNEL_EPOCH
    ADMIN_ACCESS                = 5;

}




/**********************************************************************************************************************
EntryOp specifies a specific flavor of PDI transaction.  Although the PLAN UI will not allow the user to things 
she doesn't have permission to do, every pnode in the community rigorously verifies that the author of any given 
PDI entry has the permission they imply they do with the given entry they authored.  */
enum EntryOp {

    // Appends this content entry to the specified channel.
    POST_CONTENT                = 0;

    // This entry's body lists one or more channel entry IDs to mark as removed/invisible.
    REMOVE_ENTRIES              = 1;

    // This entry's body replaces the specified previous entry.
    SUPERSEDE_ENTRY             = 2;

    // This entry modifies one or more of a given channel's meta fields (e.g. channel description, icon, etc).
    // A channels "current" composite is constructed by sequentially applying every EDIT_CHANNEL_INFO 
    //    change to the previous ChannelInfo composite up to the present time.
    // Only channel admins or moderators are permitted to originate this op.
    EDIT_CHANNEL_INFO           = 3;

    // This entry initiates a new channel epoch, inserting one or more changes to the channel's current ChannelEpoch.
    // This op is mostly issued to access channels since a new epoch is only needed in order to rekey a private access channel.
    // Only channel admins are permitted to originate this op.
    NEW_CHANNEL_EPOCH           = 4;

    /*****************************************************
    ** Access Control Channels ONLY 
    **/

    // Adds or removes access to given member IDs or wildcards.  Notes:
    //   - This entry type is only valid for use channels that are access control channels.
    //   - Members with MODERATOR_ACCESS can only grant/revoke READ_ACCESS and READWRITE_ACCESS.
    //   - Members with ADMIN_ACCESS can grant/revoke up to and including SUPER_MODERATOR_ACCESS.
    //   - ADMIN_ACCESS can ONLY be granted by members with ADMIN_ACCESS in the parent access control channel.
    //   - In some cases, this entry type MAY result a new channel epoch to be initiated (this is because
    //     a private channel must issue and distribute a new channel encryption key in order to effectively 
    //     remove access to members that are longer have channel access).
    EDIT_ACCESS_GRANTS          = 6;

}



message AccessControls {


}




message AccessGrant {

    // Specifies an access level granted to the given list of grantees. If a pnode sees an access grant given by a member who does
    // not have permission to do so, the entry will be rejected. 
                AccessLevel         access_level                = 1;


    // List of community member IDs being given the specified access grant. 
    // Note: if grantees[0] == "*" AND access_grant <= MODERATOR_ACCESS, then the grant implicitly applies to ALL community members. 
    repeated    uint32              grantees                    = 2;

}



/*
    ChannelEpoch contains critical and security-related properties about a channel and is king while in effect.
    Other than access grants given or taken away, a ChannelEpoch is immutable and only a NEW_CHANNEL_EPOCH op can change things.
*/
message ChannelEpoch {

    // Identifies this ChannelEpoch and originates from the entryID that published this ChannelEpoch.
    // This is packed as nil and the repo fills this in during processing (since it is only knowable after signing)
                bytes               epochTID                    = 1;

    // Names the ChannelEpoch being superseded. 
    // Set to nil if there was no previous epoch and this ChannelEpoch reflects channel genesis.
                bytes               prev_epochTID               = 2;

    // Number of seconds the previous epoch can alternatively be used in place of this epoch.
                int64               epoch_transition_period     = 3;

    // Identifies the community epoch that was in effect (fore the author) when this channel epoch was published.
    // If this epoch was generated against the community's genesis epoch, this is set to nil.
    // 
                bytes               community_epochID           = 4;

    /*  Top-level string describing how entries on this channel are expected to conform.
        This allows a PLAN client to invoke the appropriate UI and data handlers. 
        e.g. 
            /plan/channel-protocol/talk/2
            /plan/channel-protocol/inventory/1   
            /plan/channel-protocol/cryptokitty/browser    */
                string              ch_protocol                 = 5;

    // Specifies the Access Control Channel that authorizes entry to be live.
                bytes               ACC                         = 6;

    // If set, channel entries can be retroactively marked to be removed/superceded via EntryOp.SUPERSEDE_ENTRY
                bool                entries_supersedable        = 8;

    // If set, entries_supersedable (above) can be changed by subsequent channel epochs.
    // IMMUTABLE
                bool                supersedable_is_mutable     = 9;

    // If set, nodes with web services running are allowed share this channel to outside the community
                bool                is_externally_shared        = 10;

    // If set, entries in this channel are "private", meaning that each entry body is encrypted using the key
    //    identified by this pub key (stored in the keyring with a name formed by the community ID and channel ID).
    // Key distribution occurs when the new channel epoch was posted (and when new members are given private channel access).
                bytes               pub_key                     = 11;

    // For unrestricted channel protocol use
                plan.Block          extensions                  = 12;


    /*****************************************************
    ** Access Control Channels ONLY (n/a otherwise)
    **/
                        
    /*  When a channel is an ACC, it's used to validate EntryOps applied to other channels (including other access channels).
        Entries in an access channel conform to a specific protocol and serve to:
            (a) allow one or more other channels to cite this channel as their access control channel (.ACC)
            (b) transport private channel keys and grants to community members that have been given access to this channel (by encrypting a channel's key using a member's public key)
            (c) publish and transfer write-access and ownership permissions to others (only permitted by owners)  */

    // This is the channel access level for members NOT specified in access_grants.
                AccessLevel         default_access_level        = 20;

    // Maps a given member ID number to an AccessLevel
    // Contains all the access grants published via EDIT_ACCESS_GRANTS sent to this channel (during this epoch).
    map<        uint32,
                AccessLevel>        access_levels               = 21;


    /*****************************************************
    ** Repo use only -- (set to nil during creation/packing)
    **/

    // Entry URID that contains this ChannelEpoch.
    // A repo sets this and uses it when writing a dependencies against this epoch for validation,
                //bytes               entryURID                   = 30;


}


message ChAttribsEdit {

    repeated    string              attribs_to_remove           = 1;

    // Attribs to add (indexed byt <item>.Label)
    repeated    plan.Block          attribs_to_add              = 2;
  
}



// ChInfo is a composite of or more ChAttribsEdit.
message ChInfo {

    // Only used when ChInfo is being used to communicate info to others; set to nil otherwise.
                ChannelEpoch        epoch                       = 1;

    // Channel attribs, indexed by <attrib>.Label
    // This is a composite of any sequence of ChAttribsEdit.
    repeated    plan.Block          attribs                     = 2;
  
}







enum EntryVersion {
    V0                          = 0;
}


/*
    EntryCrypt is the "wire" format for PLAN's Persistent Data Interface (PDI) entries.  It contains no revealing information and
    is what's sent to/from community data store replicators, such as NEM, DFINITY, and Ethereum.
*/
message EntryCrypt {
                bytes               community_epochID           = 1;        // Needed to access header_crypt
                bytes               packed_entry                = 2;        // Wrapped w/ ski.SigHeader
}


// EntryTID identifies the contained IDs in EntryInfo.TIDs. 
enum EntryTID {
    
    // The ID of this entry.  It can only be formed AFTER an entry is sealed since the "sig" portion is derived from the entry's hash..
    EntryID                 = 0;

    // Entry reference to the member record used to sign and authorize this entry.
    AuthorEntryID           = 1;

    // A reference to to the ChannelEpoch that was in effect when this entry was authored.
    ChannelEpochEntryID     = 2;

    // Entry ID of the receiving chanel's ACC that authorizes this entry
    ACCEntryID              = 3;

    // The number of TIDs in a normal entry
    NormalNumTIDs           = 4;

}



/*
    An encrypted PDI entry has two segments, its header and "body" (content) block.  The header, EntryInfo, is "community-private",
    meaning that it is encrypted using one of the community's shared symmetric keys.  The entry's body is either also community-private
    (encrypted with the same community key as EntryInfo), or it is encrypted using the key referenced by body_key_id.
*/
message EntryInfo {
                EntryOp             entry_op                    = 1;
                sint32              entry_sub_op                = 2;        // A value that sub-identifies the type/purpose of this entry IAW with the ch protocol. 
                bytes               channelID                   = 4;        // Channel that this entry is posted to.

                // TIDs corresponding to TID (above)
                // len(TIDs) == NumEntryTIDs * TIDSz
                bytes               TIDs                        = 5;
                bytes               supersedes_entryID          = 6;

                plan.Block          extensions                  = 11;       // Available for unrestricted client use.

    // Repo internal use only; set to nil for all published entries -- see ValidateAuthor()
                bytes               author_sig                  = 20;


}


enum CommunityChID {

    // RootACC is the community's root access-level channel, meaning this channel effectively
	// specifies which community members are "community admins".  All other channels and access channels
	// are ultimately controlled by the community members listed in this root channel.  This means
	// the hierarchy of access channels is rooted in this channel.
    //
    // Unlike every other ACC in a given community, the root ACC has no parent governing ACC
    RootACC                 = 0;

    // MemberRegistry is the community's master (community-public) member registry.  Each entry specifies a
	// each community member's member ID, latest public keys, and member info (e.g. home ChannelID).  This allows each of the
	// community's pnodes to verify member signatures and enable the passing of secrets to other members or groups
	// via asymmetric encryption. Naturally, this channel is controlled by an access channel that is controlled only
	// by community admins and is set to RootAccessChannel by default.  Since each entry in this channel represents
	// an official community record (that only a community admin can edit), entries can also contain additional
	// information desired that community admins wish (or require) to be publicly available (and unforgeable).
    MemberRegistry          = 1;

    // EpochHistory identifies the channel where successive CommunityEpoch entries are posted
    EpochHistory            = 2;

    // The total number of community-global channels needed in order to administer a PLAN community.
    NumChannels             = 3;                  
}



// StorageEpoch contains core params req'd for a community (and StorageProviders for that community) 
// During community genesis, the newly created StorageEpoch is marshalled and signed by OriginKey
message StorageEpoch {

    // OriginKey is a signing key that:
    //    a) models for others how to generate their own signing key for use with this StorageProvider network.
    //    b) uniquely identifies this StorageEpoch (useful as a keyring name specific to this storage epoch).
                ski.KeyInfo         origin_key                  = 1;

    // Identifies a txn encoding schema and storage behavior.
    // Multicodec-style construction, e.g. "plan/storage/pdi-eth/1"
                string              storage_protocol            = 2;

    // Which community this storage provider hosts.
                bytes               communityID                 = 3;

    // Human-readable name of this storage epoch (not necessarily the community's name)
                string              name                        = 4;

   // Hash kit used to hash PDI txns
                ski.HashKitID       txn_hash_kit                = 6;

    // Max byte size of txns allowed to be posted to StorageProviders with this epoch.
                uint32              txn_max_size                = 7;

    // List of CommunityChID, identifying essential channel IDs for this community's reserved channel set.
                bytes               community_chIDs             = 8;

    // List of entry TIDs that are considered automatically valid at all times.
    repeated    bytes               genesis_entryIDs            = 9;
}



message CommunityEpoch {


   // Immutable -- the community ID and community keyring name.
                bytes               communityID                 = 1;

    // Official community name
                string              community_name              = 2;

    // CryptoKit that members should/must use to sign newly authored entries.
                ski.CryptoKitID     signing_crypto_kit          = 3;

    // CryptoKit used for default crypto ops.
                ski.CryptoKitID     default_crypto_kit          = 4;

    // Hash kit used to hash PDI entries
                ski.HashKitID       entry_hash_kit              = 5;

    // The community key associated with this epoch, identifying this epoch.
    // KeyInfo.KeyType_SymmetricKey
    // Note that KeyInfo.CryptoKit specified here is also used when generating member asymmetric keys 
                ski.KeyInfo         key_info                    = 6;

    // Identifies this CommunityEpoch.
    // This value is the entryTID of the entry that bourne this CommunityEpoch (if applicable)
                bytes               epochTID                    = 7;

    // Names the ChannelEpoch being superseded. 
    // Set to nil if there was no previous epoch and this CommunityEpoch reflects community genesis.
                bytes               prev_epochTID               = 8;

    // This is how "standard" channels are discovered. 
    repeated    plan.Link           links                       = 10;

    // Max delay (in secs) allowed between pdi.EntryInfo.TimeAuthored of an incoming entry
    //    and the TimeAuthored value of the most recently witnessed entry.  The idea is, how
    //    can entries arrive days or weeks and then a back-dated entry arrives (preventing 
    //    "submarine" attacks). 
    // Note: this only applies to non-private ACCs.
                int64               max_member_latency          = 30;

    // Max number of seconds that any two community peers could have different clock readings.
    // This value implies a dependency time "slop" for validation.  That is, no entry can be dependent on another
    //     entry that is more than this value in the future.  Beyond this, this is a causality inconsistency.
                int64               max_member_clock_delta      = 31;

    // Max number of seconds delay between pdi.EntryInfo.TimeAuthored and its corresponding TxnInfo.TimeSealed.
    // Otherwise, entries that are sealed too late are auto-rejected during entry processing.
    // The downside of larger number is that it limits how long members can be offline until
    //     newly authored entries will be auto-rejected due to this security constraint.
    // Tier 0: posts to reserved community channels
    // Tier 1: posts to public ACCs 
    repeated    int64               max_entry_latency           = 32;

}


// MemberEpoch publishes a PLAN community member's public keys and other "community-public" info.
// Members of a community uses its reserved MemberRegistryChannel as the starting point 
//    to get critical community-public info about other members.  This process basically
//    involves fetching the most recently published MemberEpoch by a member.
// In effect, this allows community members to:
//    (1) open cryptographically secure channels with other members
//    (2) verify member sigs on channel entries (to ensure that they are authentic)
//    (3) generate and publish new keys when personal security has been compromised. 
message MemberEpoch {

    // Identifies this MemberEpoch for a given member ID (and is nil during creation since the TID is not yet known).
    // This value is the entryTID of the entry that bears this MemberEpoch.
                bytes               epochTID                    = 1;

    // Immutable -- generated during member genesis.
    // To ensure new member ID async uniqueness, community admins lease/reserve member ID ranges they are allowed to issue within.
                uint32              memberID                    = 2;    

    // Unix timestamp when this epoch entered into effect
                int64               time_started                = 5;

    // Specifies a UTF8 textual label that this member chooses to appear as in the community.
                string              alias                       = 6;

    // Public keys associated with this member epoch
                bytes               pub_signing_key             = 7;
                bytes               pub_encrypt_key             = 8;

    // Future-proofing
                plan.Block          extensions                  = 9;

    // The ChannelID of this member's "about" channel
                bytes               about_chID                  = 20;

    // The ChannelID of this member's home channel -- where visitors should first go
                bytes               home_chID                   = 21;

    // Channel of this memeber's contact channel
                bytes               contact_chID                = 22;

    // User root ACC.  
                bytes               member_ACC                  = 23;




    /*****************************************************
    ** Repo use only -- (set to nil during creation/packing)
    **/

    // Entry URID that contains this MemberEpoch.
    // A repo sets this and uses it when writing a dependencies against this epoch for validation,
                //bytes               entryURID                   = 20;
}




